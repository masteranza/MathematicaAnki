(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["ScienceReport`",{"ErrorBarPlots`","PackageUtils`"}];

RefPic::usage ="Refers to a FigureCaptionNumbered";
RefEq::usage ="Refers to an EquationNumbered";

Mes::usage="Container for messurments Mes[value,error,unit]";
SimpleTable::usage="Grid with some simple formatting options and optional label with comment";
EquationNumbered::usage="Assigns function to it's name and prints it nicely";
LinearRegressionXYError::usage="Assigns function to it's name and prints it nicely";
PlotRegression::usage="Takes linear regression model with uncertainties, data, errors and label plots to plot them all together";
StackVar::usage="Takes variable and appends it to tvars list for later usage";
PresentValue::usage="Changes list {var,err,unit} to nice format"; TotalDiffrentialError::usage="Presents and calculates the expression for error";
da::usage="Calculates error of a given lm fit";
db::usage="Calculates error of b";

RefLastPic::usage ="Inserts number of last FigureCaptionNumbered";
StyledPlot::usage="Creates a styled Plot with grid";
StyledListPlot::usage="Creates a styled ListPlot with grid";
StyledListLogPlot::usage="Creates a styled ListLogPlot with grid";
StyledErrorListPlot::usage="Creates a styled ErrorListPlot with grid";
StyledErrorListPlotRegression::usage="Creates a styled ErrorListPlot with grid and given linear regression";
Begin["`Private`"];

RefPic[tag_] := NotebookWrite[EvaluationNotebook[], RowBox[{"[", CounterBox["FigureCaptionNumbered", ToString@tag], "]"}]]
RefEq[tag_] := NotebookWrite[EvaluationNotebook[], RowBox[{"[", CounterBox["EquationNumbered", ToString@tag], "]"}]]

StyledPlot[x__]:=Style[Plot[x,Frame->True, ImageSize->500,GridLines->Automatic, GridLinesStyle->Directive[Gray,Dashed]],TextAlignment->Center];
StyledListPlot[x__]:=Style[ListPlot[x,Frame->True, ImageSize->500,GridLines->Automatic, GridLinesStyle->Directive[Gray,Dashed]],TextAlignment->Center];
StyledListLogPlot[x__]:=Style[ListLogPlot[x,Frame->True, ImageSize->500],TextAlignment->Center];
StyledErrorListPlot[x__]:=Style[ErrorListPlot[x,Frame->True, ImageSize->500,GridLines->Automatic, GridLinesStyle->Directive[Gray,Dashed]],TextAlignment->Center];
StyledErrorListPlotRegression[y__,lm_]:=Style[Show[ErrorListPlot[y,Frame->True, ImageSize->500,GridLines->Automatic, GridLinesStyle->Directive[Gray,Dashed],Epilog->Inset[Framed[lm["ParameterTable"],Background->LightGreen],{Axis,Top},{Left,Top}]],
Plot[lm[x],{x,0,1000}, PlotLegends->Placed[ "y"==Normal[lm],Above],ImageSize-> 500]],TextAlignment->Center];

SimpleTable[data_, labels_: {}, accuracy_:4] :=
Return[Style[NumberForm[Grid[If[labels != {}, Prepend[data, labels]], {Background -> {None, {{White, Lighter[Blend[{Gray, Gray}], 0.85`]}}},
Alignment->If[labels != {},{Automatic,{Center,"."}},"."],
ItemStyle->If[labels != {},{Automatic,{Directive[Bold,Larger],{Automatic}}},Automatic],
Dividers->{{Gray,{LightGray},Gray}}, Alignment -> Right, Frame -> True, Spacings -> {2,If[labels != {}, {1, {0.3`}},{0.3`}]}}],{3+accuracy,accuracy}], "Table", TextAlignment -> Center]];


LinearRegressionXYError[data_?MatrixQ, errs_?MatrixQ] := Module[{n = Length[data], c, ct, dk, dm, k, m, p, s, st, ul, vl, w, wt, xm, ym}, {ct, st, k} = Flatten[MapAt[Normalize[{1, #}] &, NArgMin[Norm[Function[{x, y}, y - \[FormalM] x - \[FormalK]] @@@ data], {\[FormalM], \[FormalK]}], 1]];
   (*find orthogonal regression coefficients*){c, s, p} = FindArgMin[{Total[(data.{-\[FormalS], \[FormalC]} - \[FormalP])^2/((errs^2).{\[FormalS]^2, \[FormalC]^2})], \[FormalC]^2 + \[FormalS]^2 == 1}, {{\[FormalC], ct}, {\[FormalS], st}, {\[FormalP], k/ct}}];
   (*slope and intercept*){m, k} = {s, p}/c;
   wt = 1/errs^2; w = (Times @@@ wt)/(wt.{1, m^2});
   {xm, ym} = w.data/Total[w];
   ul = data[[All, 1]] - xm; vl = data[[All, 2]] - ym;
   (*uncertainties in slope and intercept*)dm = w.(m ul - vl)^2/w.ul^2/(n - 2);
   dk = dm (w.data[[All, 1]]^2/Total[w]);
   {Function[\[FormalX], Evaluate[{m, k}.{\[FormalX], 1}]], Sqrt[{dm, dk}]}] /; Dimensions[data] === Dimensions[errs]

bigImgSize = 550;
smallImgSize = 350;

PlotRegression[lr_, data_, errors_, labels_: {},func_:True,range_:Automatic] := Module[{dataErrors, names},
   dataErrors = MapThread[{#1, ErrorBar[#2[[1]], #2[[2]]]} &, {data, errors}];
   names = {lr[x], x*lr["ParameterConfidenceIntervals"][[2, 1]] + lr["ParameterConfidenceIntervals"][[1, 1]], x*lr["ParameterConfidenceIntervals"][[2, 2]] + lr["ParameterConfidenceIntervals"][[1, 2]]};
   Return[Show[ErrorListPlot[dataErrors,PlotMarkers->{Automatic,4},ErrorBarFunction->If[func,Function[{coords, errs}, {Opacity[0.3],Rectangle[coords+{errs[[1,1]],errs[[2,1]]},coords+{errs[[1,2]],errs[[2,2]]}]}],Automatic], ImageSize -> bigImgSize, Frame -> True, PlotRange->range,FrameStyle -> Gray, FrameLabel -> labels, GridLines -> Automatic, GridLinesStyle -> Directive[Gray, Dashed]], Plot[names, {x, 0, First[Last[data]]}, PlotStyle -> {Directive[Thick, Red], Directive[Dashed, Darker[Gray]], Directive[Dashed, Darker[Gray]]}, PlotLegends -> Placed[names, Above]]]]
   (*,TextAlignment\[Rule]Center]];*)
   ];

da[lr_] := Abs[D[lr[x], x] - lr["ParameterConfidenceIntervals"][[2, 1]]];
db[lr_] := Abs[lr[0] - lr["ParameterConfidenceIntervals"][[1, 1]]];

M[x_] := QuantityMagnitude[x];
Q[x_, u_] := Quantity[x, u];
FixUnit[x_, jednostka_] := UnitConvert[x, Quantity[jednostka]]
PresentValue[var_, units_ : "", prec_ : 2] := NumberForm[If[units == "", Q[var[[1]] \[PlusMinus] var[[2]], var[[3]]], Q[M[FixUnit[Q[var[[1]], var[[3]]], units]] \[PlusMinus] M[FixUnit[Q[var[[2]], var[[3]]], units]], units]], {20, prec}];

Mes/:C_ Mes[x_,dx_,u_]:=Mes[M[C] x,M[C] dx,QuantityUnit[C] u]/; QuantityQ[C];

Mes/:C_ Mes[x_,dx_,u_]:=Mes[C x,C dx,u]/; NumberQ[C];

Mes/:Mes[x_,dx_,u_]+Mes[x2_,dx2_,u2_]:=Mes[x+x2,Sqrt[dx^2+dx2^2],u]/; u==u2;

Mes/:Mes[x_,dx_,u_]-Mes[x2_,dx2_,u2_]:=Mes[x-x2,Sqrt[dx^2+dx2^2],u]/; u==u2;

Mes/:Mes[x_,dx_,u_]*Mes[x2_,dx2_,u2_]:=Mes[x*x2,Sqrt[(x2 dx)^2+(x dx2)^2 ],(u ) *(u2)];
Mes/:Mes[x_,dx_,u_] / Mes[x2_,dx2_,u2_]:=Mes[x/x2,Sqrt[( dx/x2)^2+( dx2 x/(x2)^2)^2 ],(u) /(u2)];

Mes/:Exp[Mes[x_,dx_,u_]]:=Mes[Exp[x],Exp[x] dx,u];
Mes/:Sin[Mes[x_,dx_,u_]]:=Mes[Sin[x],Abs[Cos[x]] dx,u];
Mes/:Cos[Mes[x_,dx_,u_]]:=Mes[Cos[x],Abs[Sin[x]] dx,u];
Mes/:Power[Mes[x_,dx_,u_],n_]:=Mes[Power[x,n],Power[x,n-1] dx, u^n]/; NumberQ[n];

Mes/:MakeBoxes[Mes[mess_,error_,unit_],form:(StandardForm|TraditionalForm):StandardForm]:=
RowBox[{MakeBoxes[NumberForm[Quantity[mess \[PlusMinus] error,unit],{20,2}],form]}]

(*Error alone is not subject to formatting*)
Mes/:MakeBoxes[Mes[0,error_,unit_],form:(StandardForm|TraditionalForm):StandardForm]:=
RowBox[{MakeBoxes[Quantity[error,unit],form]}]

Mes/:MakeBoxes[Mes[mess_,0,unit_],form:(StandardForm|TraditionalForm):StandardForm]:=
RowBox[{MakeBoxes[NumberForm[Quantity[mess,unit],{20,2}],form]}]
Mes/:\[CapitalDelta][Mes[value_,error_,unit_]]:=error;

SetAttributes[EquationNumbered,HoldAllComplete];
EquationNumbered[fun_, tags_: ""] := 
   StylePrint[HoldForm[fun] ==fun, "EquationNumbered", CellTags -> tags];

SetAttributes[DD,HoldFirst];
DD[f_,var_]:=HoldForm[\!\(
\*SubscriptBox[\(\[PartialD]\), \(var\)]f\)];
(*CSE[e_]:=ToExpression[If[StringFreeQ[ToString[e,InputForm],"Subscript["],"\[CapitalDelta]"<>ToString[e]<>"",StringReplace[ToString[e,InputForm],"Subscript["\[Rule]"Subscript[\[CapitalDelta]"]]];*)
SetAttributes[CSE,HoldFirst];
CSE[e_]:=ToExpression[If[StringFreeQ[ToString[FullForm@HoldForm@e],"HoldForm[Subscript["],"\[CapitalDelta]"<>ToString[HoldForm@e]<>"",StringReplace[ToString[FullForm@HoldForm@e],"HoldForm[Subscript["->"HoldForm[Subscript[\[CapitalDelta]"]],TraditionalForm,HoldForm];
(*CSE[e_]:=Print[HoldForm@e]*)
SetAttributes[TDE,HoldFirst];
TDE[fun2_,vars2__]:=Sqrt[Sum[i,{i,((CSE[#] DD[fun2,#])^2)&/@ vars2}]];
(*TDE[fun2_,vars2__]:=Print[HoldForm@{vars2}];*)

SetAttributes[TotalDiffrentialError,HoldFirst];
TotalDiffrentialError[fun_,vars__]:=Module[{Expanded},
StylePrint[CSE[fun]==TDE[fun,vars],"EquationNumbered"];
StylePrint[CSE[fun]==FullSimplify[ReleaseHold[TDE[fun,vars]],TransformationFunctions->{Automatic,PowerExpand}],"EquationNumbered"];
FullSimplify[ReleaseHold[TDE[fun,vars]]]];



End[];
EndPackage[];
